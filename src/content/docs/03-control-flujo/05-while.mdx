---
title: Bucle While
description: Aprende más sobre mi proyecto en este sitio de documentación construido con Starlight.
---

El ciclo `while` en Rust permite repetir un bloque de código mientras una condición se mantenga verdadera. A diferencia de `loop`, que se ejecuta indefinidamente hasta que se use un `break`, el ciclo `while` solo continúa mientras la expresión booleana asociada sea verdadera. Esta característica lo hace útil para situaciones donde se conoce la condición de salida o cuando el número de iteraciones depende de factores dinámicos.

## Ciclo `while`

El ciclo `while` ejecuta repetidamente un bloque de código siempre que la condición evaluada resulte verdadera. Al igual que en otros lenguajes de programación, esta condición se verifica antes de ejecutar cada iteración del ciclo.

```rust
fn main() {
    let mut contador = 0;

    while contador < 5 {
        println!("Contador: {}", contador);
        contador += 1;
    }
}
```
- El ciclo `while` se ejecuta mientras la variable `contador` sea menor que 5.
- En cada iteración, se imprime el valor de `contador` y se incrementa en uno.
- El ciclo termina cuando `contador` llega a 5.

## `break` y `continue`

Al igual que con otros ciclos, podemos controlar el flujo del ciclo `while` con las instrucciones `break` para salir del ciclo anticipadamente y `continue` para saltar a la siguiente iteración sin ejecutar el resto del bloque.

```rust
fn main() {
    let mut contador = 0;

    while contador < 10 {
        println!("Contador: {}", contador);
        
        if contador == 7 {
            break; // Sale del ciclo cuando contador es igual a 7
        }

        contador += 1;
    }

    println!("El ciclo terminó");
}
```
- El ciclo se detiene cuando `contador` llega a 7, usando `break`.
- Aunque la condición original del ciclo era `contador < 10`, el ciclo termina antes de llegar a ese punto debido al uso de `break`.

```rust
fn main() {
    let mut contador = 0;

    while contador < 10 {
        contador += 1;

        if contador % 2 == 0 {
            continue; // Salta la impresión si el número es par
        }

        println!("Número impar: {}", contador);
    }
}
```
- El ciclo incrementa `contador` en cada iteración.
- Si el valor de `contador` es par, se salta la impresión y continúa con la siguiente iteración gracias a la instrucción `continue`.

## Ciclo Infinito

Aunque el ciclo `while` generalmente se usa con condiciones que eventualmente serán falsas, también puede utilizarse para crear ciclos infinitos con `while true`. En este caso, el ciclo se ejecutará indefinidamente, a menos que se use `break`.

```rust
fn main() {
    let mut contador = 0;

    while true {
        contador += 1;

        if contador == 5 {
            println!("Rompiendo el ciclo...");
            break; // Rompe el ciclo en la quinta iteración
        }

        println!("Contador: {}", contador);
    }
}
```
- El ciclo `while true` continúa indefinidamente hasta que se alcanza la condición `contador == 5`, momento en el que se usa `break` para detener el ciclo.
- Este tipo de bucle es útil en ciertas aplicaciones donde el ciclo debe continuar hasta que ocurra un evento específico.

## Retornos

Si se necesita retornar un valor desde un ciclo `while`, esto se puede hacer usando `break` seguido de un valor, lo cual es útil en ciertos algoritmos donde se busca un resultado a través de la iteración.

```rust
fn main() {
    let mut contador = 0;

    let resultado = while contador < 10 {
        contador += 1;

        if contador == 7 {
            break contador * 2; // Retorna el doble de 7 cuando se alcanza
        }
    };

    println!("Resultado: {}", resultado);
}
```
- El ciclo `while` retorna un valor usando `break` con el valor `contador * 2` cuando `contador` llega a 7.
- El valor retornado se asigna a la variable `resultado`.

## Conclusión

El ciclo `while` en Rust es una herramienta versátil para manejar la ejecución repetida de bloques de código, siempre que una condición sea verdadera. Desde los usos más básicos, como ciclos con condiciones simples, hasta casos avanzados en los que las condiciones son dinámicas o se retornan valores, el ciclo `while` permite un control preciso del flujo de ejecución en Rust.

Al entender cómo combinar `while` con características adicionales, como `break`, `continue`, y condiciones dinámicas, puedes implementar soluciones eficaces para problemas de la vida real, tales como la gestión de tareas concurrentes, el procesamiento de datos en tiempo real, o la simulación de fenómenos físicos.