---
title: Controlando el Flujo de Bucle
description: Aprende más sobre mi proyecto en este sitio de documentación construido con Starlight.
---

En programación, a menudo encontramos situaciones en las que necesitamos salir de un bucle antes de que se complete su ejecución completa. En Rust, esto se puede lograr utilizando las palabras clave `break` y `continue`. En este artículo, exploraremos cómo funcionan estas palabras clave y cómo pueden hacer que nuestro código sea más eficiente y fácil de entender.

## Ejemplo de `while`

Consideremos el siguiente bucle `while` que realiza una suma acumulativa hasta que alcanzamos un valor específico:

```rust
let mut total = 0;
let mut count = 1;

while total < 20 {
    total += count;
    println!("Suma acumulativa: {}", total);
    count += 1;
}
```

En este código, utilizamos una variable `total` que se incrementa en cada iteración. Mientras `total` sea menor que 20, el bucle continuará ejecutándose. Aunque esto funciona, podemos hacerlo más simple.

## Uso de `break`

Podemos reescribir el bucle utilizando la palabra clave `break`, que termina el bucle de manera más clara:

```rust
let mut total = 0;
let mut count = 1;

loop {
    total += count;
    println!("Suma acumulativa: {}", total);
    
    if total >= 20 { break; }
    
    count += 1;
}
```

Aquí, utilizamos `loop` para crear un bucle infinito y luego usamos `break` para salir del bucle de manera anticipada. Esto hace que el código sea más sencillo y fácil de leer.

## Uso de `continue`

La palabra clave `continue` funciona de manera diferente. En lugar de terminar el bucle, `continue` salta a la siguiente iteración. Esto es útil si queremos omitir ciertos casos en una iteración. Por ejemplo, el siguiente código imprime todos los números del 1 al 10, pero omite los números que son divisibles por 3:

```rust
for num in 1..11 {
    if num % 3 == 0 { continue; }

    println!("Número: {}", num);
}
```

En este caso, cuando `num` es divisible por 3, `continue` provoca que el programa salte a la siguiente iteración del bucle, evitando la impresión de esos números.

## Etiquetas de bucle

A veces, trabajamos con bucles anidados y necesitamos especificar a cuál de los bucles aplicamos `break` o `continue`. En Rust, por defecto, estas palabras clave aplican al bucle más interno. Para romper o continuar uno de los bucles exteriores, podemos usar etiquetas.

En el siguiente ejemplo, queremos continuar a la siguiente iteración del bucle exterior cuando `i` es par, y continuar a la siguiente iteración del bucle interior cuando `j` es mayor que 5. Esto garantiza que solo se ejecute `println!` cuando `i` es impar y `j` es menor o igual a 5:

```rust
'outer: for i in 1..10 {
    'inner: for j in 1..10 {
        if i % 2 == 0 { continue 'outer; } // Continúa el bucle sobre `i`.
        if j > 5 { continue 'inner; } // Continúa el bucle sobre `j`.
        println!("i: {}, j: {}", i, j);
    }
}
```

Aquí, `continue 'outer;` permite que el bucle exterior se salte a la siguiente iteración, mientras que `continue 'inner;` hace lo mismo para el bucle interior.

## Conclusión

Las palabras clave `break` y `continue` en Rust son herramientas poderosas que nos permiten controlar la ejecución de los bucles de manera más flexible y legible. Al utilizar `break`, podemos salir de un bucle anticipadamente cuando se cumplan ciertas condiciones, y con `continue`, podemos omitir la ejecución de una iteración en casos específicos. Además, las etiquetas de bucle nos permiten trabajar de manera efectiva con bucles anidados, lo que mejora la claridad y la intención de nuestro código. Utilizar estas herramientas correctamente puede ayudar a hacer que nuestro código sea más eficiente y fácil de entender.