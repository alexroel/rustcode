---
title: Pr谩ctica - Registro de estudiantes
description: En esta pr谩ctica, aprender谩s c贸mo usar estructuras y colecciones de datos en Rust para crear un registro de estudiantes. Aprender谩s c贸mo definir una estructura para representar a un estudiante, c贸mo crear un vector de estudiantes, c贸mo agregar y quitar estudiantes del registro y c贸mo buscar estudiantes por nombre.
---

En esta pr谩ctica, aprender谩s c贸mo usar estructuras y colecciones de datos en Rust para crear un registro de estudiantes. Aprender谩s c贸mo definir una estructura para representar a un estudiante, c贸mo crear un vector de estudiantes, c贸mo agregar y quitar estudiantes del registro y c贸mo buscar estudiantes por nombre.

## Requerimientos

Para completar esta pr谩ctica, necesitamos tener encuenta los siguientes requerimientos:

- El programa tiene que tener un men煤 con las siguientes opciones:
  1. Agregar estudiante
  2. Eliminar estudiante
  3. Listar estudiantes
  4. Salir

- Para agregar un estudiante, el programa debe solicitar el nombre y la edad del estudiante al usuario y agregarlo al registro de estudiantes.

- Para eliminar un estudiante, el programa debe solicitar el n煤mero de registro del estudiante a eliminar y eliminarlo del registro de estudiantes.

- Para listar los estudiantes, el programa debe mostrar una lista de todos los estudiantes en el registro.

- El programa debe salir cuando el usuario seleccione la opci贸n de salir.

## Soluci贸n de la pr谩ctica

Para completar esta pr谩ctica, sigue los siguientes pasos:

1. Define una estructura llamada `Estudiante` con los campos `nombre` de tipo `String` y `edad` de tipo `u8`.
2. Crea un vector llamado `registro` para almacenar los estudiantes.
3. Implementa un bucle infinito que muestre el men煤 y solicite al usuario que seleccione una opci贸n.
4. Implementa la l贸gica para cada opci贸n del men煤:
   - Para la opci贸n de agregar estudiante, solicita el nombre y la edad del estudiante al usuario y agrega un nuevo estudiante al registro.
   - Para la opci贸n de eliminar estudiante, solicita el n煤mero de registro del estudiante a eliminar y elimina el estudiante del registro.
   - Para la opci贸n de listar estudiantes, muestra una lista de todos los estudiantes en el registro.
   - Para la opci贸n de salir, finaliza el programa.

Aqu铆 tienes un ejemplo de c贸mo podr铆a verse la soluci贸n de esta pr谩ctica:

```rust
use std::io::{stdin, stdout, Write};
use std::collections::HashMap;

// Enumeraci贸n para tipo de contrato
#[derive(Debug)]
enum ContractType {
    TiempoCompleto,
    MedioTiempo,
    Temporal,
}

// Estructura para empleado
#[derive(Debug)]
struct Employee {
    name: String,
    age: u8,
    salary: f64,
    contract: ContractType,
}

// Implementaci贸n de m茅todos para la estructura Employee
impl Employee {
    // M茅todo constructor
    fn new(name: String, age: u8, salary: f64, contract: ContractType) -> Employee{
        Employee {
            name,
            age,
            salary,
            contract,
        }
    }
}

// Funci贸n para ingresar datos por teclado
fn input(prompt: &str) -> String {
    print!("{}", prompt);
    stdout().flush().unwrap();
    let mut input_data = String::new();
    stdin().read_line(&mut input_data).expect("Error al leer la entrada");
    input_data.trim().to_string()
}

fn main() {
    // Creamos un HashMap para almacenar empleados
    let mut employees: HashMap<u32, Employee> = HashMap::new();

    loop {
        // Mostramos el men煤
        println!("1. Agregar empleado");
        println!("2. Eliminar empleado");
        println!("3. Mostrar empleados");
        println!("4. Salir");

        // Solicitamos una opci贸n al usuario
        let option = input("Ingrese una opci贸n: ");

        // Convertimos la opci贸n a un n煤mero entero
        let option = option.parse::<u8>().unwrap();

        // Realizamos una acci贸n dependiendo de la opci贸n seleccionada
        match option {
            1 => {
                // Solicitamos los datos del empleado
                let name = input("Nombre del empleado: ");
                let age = input("Edad del empleado: ").parse::<u8>().unwrap();
                let salary = input("Salario del empleado: ").parse::<f64>().unwrap();
                let contract = input("Tipo de contrato (1: Tiempo completo, 2: Medio tiempo, 3: Temporal): ").parse::<u8>().unwrap();

                // Creamos un nuevo empleado
                let contract_type = match contract {
                    1 => ContractType::TiempoCompleto,
                    2 => ContractType::MedioTiempo,
                    3 => ContractType::Temporal,
                    _ => ContractType::TiempoCompleto,
                };
                let employee = Employee::new(name, age, salary, contract_type);

                // Agregamos el empleado al HashMap
                let id = employees.len() as u32 + 1;
                employees.insert(id, employee);

            },
            2 => {
                // Solicitamos el ID del empleado a eliminar
                let id = input("Ingrese el ID del empleado a eliminar: ").parse::<u32>().unwrap();

                // Eliminamos el empleado del HashMap
                employees.remove(&id);
            },
            3 => {
                // Mostramos los empleados ordenados por ID
                println!("\nLista de empleados:");

                println!("\n------------------------------------------------------------");
                for (id, employee) in employees.iter() {
                    println!("ID: {} - Nombre: {} - Edad: {} - Salario: {} - Contrato: {:?}", id, employee.name, employee.age, employee.salary, employee.contract);
                    println!("------------------------------------------------------------");
                }
                println!();
            },
            4 => {
                // Salimos del programa
                println!("Saliendo del programa...");
                break;
            },
            _ => {
                println!("Opci贸n no v谩lida");
            }
        }
    }
    
}
```

En este ejemplo, hemos definido una estructura `Employee` para representar a un empleado con los campos `name`, `age`, `salary` y `contract`. Tambi茅n hemos definido una enumeraci贸n `ContractType` para representar el tipo de contrato del empleado. Luego, hemos implementado m茅todos para la estructura `Employee`, incluyendo un m茅todo constructor `new` para crear nuevos empleados.

En la funci贸n `main`, hemos creado un `HashMap` llamado `employees` para almacenar empleados. Luego, hemos implementado un bucle infinito que muestra un men煤 y solicita al usuario que seleccione una opci贸n. Dependiendo de la opci贸n seleccionada, el programa realiza una acci贸n espec铆fica, como agregar un empleado, eliminar un empleado, mostrar la lista de empleados o salir del programa.

Puedes ejecutar este programa en tu entorno de desarrollo local para probarlo y ver c贸mo funciona. 隆Buena suerte! 





