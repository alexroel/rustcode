---
title: Tipos de datos
description: En Rust, los números se dividen en varias categorías según su tipo y si son enteros o flotantes. Existen tipos de datos específicos para representar números con signo, sin signo y números flotantes.
---

En Rust, los números se dividen en varias categorías según su tipo y si son enteros o flotantes. Existen tipos de datos específicos para representar números con signo, sin signo y números flotantes.

## Enteros
Rust ofrece varios tipos de enteros que se dividen en dos categorías: con signo y sin signo.

import { Steps } from '@astrojs/starlight/components';

<Steps>

1. **Enteros con Signo (i):**
Los enteros con signo permiten representar tanto números positivos como negativos:
    | **Tipo** | **Bits** |
    |----------|----------|
    | `i8`     | 8        |
    | `i16`    | 16       |
    | `i32`    | 32       |
    | `i64`    | 64       |
    | `i128`   | 128      |
    | `isize`  | Depende de la arquitectura |

2. **Enteros sin Signo (u):** Los enteros sin signo solo pueden almacenar números positivos:

    | **Tipo** | **Bits** |
    |----------|----------|
    | `u8`     | 8        |
    | `u16`    | 16       |
    | `u32`    | 32       |
    | `u64`    | 64       |
    | `u128`   | 128      |
    | `usize`  | Depende de la arquitectura |

</Steps>

:::tip[Tipo de entero por defecto]
En Rust, los tipos de datos por defecto son `i32` para números enteros
:::

## Flotantes

<Steps>

1. **32-bit Floating Point** Este tipo de dato usa 32 bits para representar un número en punto flotante. Es menos preciso que `f64`, pero consume menos memoria.
    ```rust
    let a: f32 = 3.14;
    let b: f32 = 2.5e2; // Notación científica (250.0)
    ```

2. **64-bit Floating Point:** Este tipo de dato utiliza 64 bits para representar un número en punto flotante. Ofrece más precisión que `f32`.

    ```rust
    let x: f64 = 3.141592653589793;
    let y: f64 = 1.0e-10; // Notación científica (0.0000000001)
    ```

</Steps>
:::tip[¿Sabías esto?]
Es el tipo de número de punto flotante por defecto en Rust, utilizado para representar números decimales con mayor precisión. 
:::

:::note
Para calcular el valor máximo y el valor mínimo de los tipos de enteros y flotantes en Rust, podemos comprobar estos valores en un programa Rust, puedes usar el siguiente código:

```rust
println!("Valores para i8: Máximo = {}, Mínimo = {}", i8::MAX, i8::MIN);
println!("Valores para i16: Máximo = {}, Mínimo = {}", f32::MAX, f32::MIN);
```

:::

## Booleanos

Los valores booleanos en Rust son representados por el tipo de dato `bool`. Este tipo de dato solo puede tener dos valores: `true` o `false`.

```rust
let is_raining: bool = true;
let is_sunny: bool = false;
``` 

## Caracteres

En Rust, el tipo de dato `char` es utilizado para representar un solo carácter Unicode. Los caracteres en Rust son escritos entre comillas simples.

```rust
let letter: char = 'A';
let emoji: char = '😀';
```

## Cadenas de texto

Las cadenas de texto en Rust son representadas por el tipo de dato `str`. Las cadenas de texto en Rust son inmutables y no pueden ser modificadas una vez que son creadas.

```rust
let message: &str = "¡Hola, mundo!";
println!("{}", message);
```

:::tip[Tipo de dato `String`]
El tipo de dato `String` es una cadena de texto dinámica que puede ser modificada. Para crear una cadena de texto `String`, puedes usar el método `to_string()`.

```rust
let mut name = "Alex".to_string();
name.push_str(" en el mundo de Rust");
println!("{}", name); // Alex en el mundo de Rust
```

:::

## Conclusiones

En Rust, los números se dividen en varias categorías según su tipo y si son enteros o flotantes. Existen tipos de datos específicos para representar números con signo, sin signo y números flotantes. Además, Rust ofrece tipos de datos para representar valores booleanos, caracteres y cadenas de texto.


