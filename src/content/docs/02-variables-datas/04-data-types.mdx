---
title: Tipos de datos
description: En Rust, los n칰meros se dividen en varias categor칤as seg칰n su tipo y si son enteros o flotantes. Existen tipos de datos espec칤ficos para representar n칰meros con signo, sin signo y n칰meros flotantes.
---

En Rust, los n칰meros se dividen en varias categor칤as seg칰n su tipo y si son enteros o flotantes. Existen tipos de datos espec칤ficos para representar n칰meros con signo, sin signo y n칰meros flotantes.

## Enteros
Rust ofrece varios tipos de enteros que se dividen en dos categor칤as: con signo y sin signo.

import { Steps } from '@astrojs/starlight/components';

<Steps>

1. **Enteros con Signo (i):**
Los enteros con signo permiten representar tanto n칰meros positivos como negativos:
    | **Tipo** | **Bits** |
    |----------|----------|
    | `i8`     | 8        |
    | `i16`    | 16       |
    | `i32`    | 32       |
    | `i64`    | 64       |
    | `i128`   | 128      |
    | `isize`  | Depende de la arquitectura |

2. **Enteros sin Signo (u):** Los enteros sin signo solo pueden almacenar n칰meros positivos:

    | **Tipo** | **Bits** |
    |----------|----------|
    | `u8`     | 8        |
    | `u16`    | 16       |
    | `u32`    | 32       |
    | `u64`    | 64       |
    | `u128`   | 128      |
    | `usize`  | Depende de la arquitectura |

</Steps>

:::tip[Tipo de entero por defecto]
En Rust, los tipos de datos por defecto son `i32` para n칰meros enteros
:::

## Flotantes

<Steps>

1. **32-bit Floating Point** Este tipo de dato usa 32 bits para representar un n칰mero en punto flotante. Es menos preciso que `f64`, pero consume menos memoria.
    ```rust
    let a: f32 = 3.14;
    let b: f32 = 2.5e2; // Notaci칩n cient칤fica (250.0)
    ```

2. **64-bit Floating Point:** Este tipo de dato utiliza 64 bits para representar un n칰mero en punto flotante. Ofrece m치s precisi칩n que `f32`.

    ```rust
    let x: f64 = 3.141592653589793;
    let y: f64 = 1.0e-10; // Notaci칩n cient칤fica (0.0000000001)
    ```

</Steps>
:::tip[쯉ab칤as esto?]
Es el tipo de n칰mero de punto flotante por defecto en Rust, utilizado para representar n칰meros decimales con mayor precisi칩n. 
:::

:::note
Para calcular el valor m치ximo y el valor m칤nimo de los tipos de enteros y flotantes en Rust, podemos comprobar estos valores en un programa Rust, puedes usar el siguiente c칩digo:

```rust
println!("Valores para i8: M치ximo = {}, M칤nimo = {}", i8::MAX, i8::MIN);
println!("Valores para i16: M치ximo = {}, M칤nimo = {}", f32::MAX, f32::MIN);
```

:::

## Booleanos

Los valores booleanos en Rust son representados por el tipo de dato `bool`. Este tipo de dato solo puede tener dos valores: `true` o `false`.

```rust
let is_raining: bool = true;
let is_sunny: bool = false;
``` 

## Caracteres

En Rust, el tipo de dato `char` es utilizado para representar un solo car치cter Unicode. Los caracteres en Rust son escritos entre comillas simples.

```rust
let letter: char = 'A';
let emoji: char = '游';
```

## Cadenas de texto

Las cadenas de texto en Rust son representadas por el tipo de dato `str`. Las cadenas de texto en Rust son inmutables y no pueden ser modificadas una vez que son creadas.

```rust
let message: &str = "춰Hola, mundo!";
println!("{}", message);
```

:::tip[Tipo de dato `String`]
El tipo de dato `String` es una cadena de texto din치mica que puede ser modificada. Para crear una cadena de texto `String`, puedes usar el m칠todo `to_string()`.

```rust
let mut name = "Alex".to_string();
name.push_str(" en el mundo de Rust");
println!("{}", name); // Alex en el mundo de Rust
```

:::

## Conclusiones

En Rust, los n칰meros se dividen en varias categor칤as seg칰n su tipo y si son enteros o flotantes. Existen tipos de datos espec칤ficos para representar n칰meros con signo, sin signo y n칰meros flotantes. Adem치s, Rust ofrece tipos de datos para representar valores booleanos, caracteres y cadenas de texto.


