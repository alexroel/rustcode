---
title: Tiempo de Vida (Lifetimes)
description: Aprende a usar anotaciones de tiempo de vida en Rust para gestionar la duraci√≥n de las referencias. 
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

En Rust, el tiempo de vida (lifetimes) es una caracter√≠stica que nos permite gestionar la duraci√≥n de las referencias en nuestro c√≥digo. Las anotaciones de tiempo de vida nos permiten especificar la relaci√≥n entre las referencias y los valores a los que apuntan, evitando problemas de seguridad y garantizando que las referencias sean v√°lidas en tiempo de ejecuci√≥n.

En este art√≠culo, aprenderemos qu√© son los tiempos de vida en Rust, c√≥mo funcionan y c√≥mo usarlos en nuestro c√≥digo. 

Supongamos que una funci√≥n toma una referencia como argumento y devuelve otra referencia. Por ejemplo, la funci√≥n recibe una referencia mutable y devuelve un mensaje modificado, en este ejemplo no es necesario especificar el tiempo de vida ya que Rust puede inferirlo autom√°ticamente:

<Tabs>
    <TabItem label="C√≥digo" icon="seti:rust">
        ```rust
        fn modificar_mensaje(mensaje: &mut String) -> &String {
            mensaje.push_str(" Rust!");
            mensaje
        }

        fn main() {
            let mut mensaje = String::from("Hola,");
            let mensaje_modificado = modificar_mensaje(&mut mensaje);

            println!("El mensaje es: {}", mensaje_modificado);
        }
        ```
    </TabItem>
    <TabItem label="Salida" icon="seti:powershell">
        ```bash
        El mensaje es: Hola, Rust!
        ```
    </TabItem>
</Tabs>

En este ejemplo, la funci√≥n `modificar_mensaje` toma una referencia mutable `mensaje` y devuelve una referencia a `mensaje`. Rust puede inferir autom√°ticamente el tiempo de vida de la referencia devuelta, ya que depende de la referencia pasada como argumento.

Sin embargo, en algunos casos, Rust no puede inferir autom√°ticamente el tiempo de vida de las referencias, por lo que necesitamos especificarlo manualmente. Para esto, usamos anotaciones de tiempo de vida en Rust.

## Por qu√© es necesario pasar una referencia a una funci√≥n

En Rust, las referencias son una forma de acceder a un valor sin transferir su propiedad. Cuando pasamos una referencia a una funci√≥n, estamos permitiendo que la funci√≥n acceda al valor sin transferir la propiedad. Esto es √∫til cuando queremos modificar un valor sin transferir su propiedad.

Por ejemplo, considera el siguiente c√≥digo, Tenemos una funci√≥n que devuelve el caracter mas largo de dos strings: Si no pasamos una referencia a la funci√≥n, la propiedad del string se transferir√≠a a la funci√≥n y no podr√≠amos usar el string despu√©s de llamar a la funci√≥n:

Sin usar anotaciones

<Tabs>
    <TabItem label="C√≥digo" icon="seti:rust">
        ```rust
        fn mas_largo(s1: String, s2: String) -> String {
            if s1.len() > s2.len() {
                s1
            } else {
                s2
            }
        }

        fn main() {
            let s1 = String::from("Lenguaje");
            let s2 = String::from("Rust");

            let c = mas_largo(s1, s2);

            // Error al intentar usar s1 y s2 despu√©s de llamar a la funci√≥n
            //println!("Palabra 1: {}", s1); 
            //println!("Palabra 2: {}", s2);

            println!("La palabra m√°s larga es: {}", c);
        }
        ```
    </TabItem>
    <TabItem label="Salida" icon="seti:powershell">
        ```bash
        La palabra m√°s larga es: Lenguaje
        ```
    </TabItem>
</Tabs>

En este ejemplo, la funci√≥n `mas_largo` toma dos `String` como argumentos y devuelve una `String`. Al pasar los `String` a la funci√≥n, transferimos la propiedad de los `String` a la funci√≥n, lo que significa que no podemos usar los `String` despu√©s de llamar a la funci√≥n.

Para evitar este problema, podemos pasar referencias a los `String` en lugar de los `String` directamente. Esto nos permite acceder a los `String` sin transferir su propiedad y seguir us√°ndolos despu√©s de llamar a la funci√≥n.

:::note
Si intentamos compilar el c√≥digo siguiente obtendremos un error de compilaci√≥n:
<Tabs>
    <TabItem label="C√≥digo" icon="seti:rust">
        ```rust
        fn mas_largo(s1: &String, s2: &String) -> &String {
            if s1.len() > s2.len() {
                s1
            } else {
                s2
            }
        }

        fn main() {
            let s1 = String::from("Lenguaje");
            let s2 = String::from("Rust");

            let c = mas_largo(&s1, &s2);

            // Error al intentar usar s1 y s2 despu√©s de llamar a la funci√≥n
            //println!("Palabra 1: {}", s1); 
            //println!("Palabra 2: {}", s2);

            println!("La palabra m√°s larga es: {}", c);
        }
        ```
    </TabItem>
    <TabItem label="Salida" icon="seti:powershell">
        ```bash
        error[E0106]: missing lifetime specifier
        ```
    </TabItem>
</Tabs>

En este caso, Rust nos pide que especifiquemos el tiempo de vida de las referencias devueltas por la funci√≥n `mas_largo`. Para solucionar este problema, necesitamos usar anotaciones de tiempo de vida en Rust.

### ‚ö† ¬øQu√© est√° mal?

- Rust no sabe si la referencia devuelta pertenece a `s1` o `s2`.
- Como no se especifica un lifetime, Rust no puede verificar que la referencia devuelta siga siendo v√°lida cuando `c` se usa en main.
- Esto causa un error de lifetime en la compilaci√≥n.
:::

## Anotaciones de tiempo de vida

Las anotaciones de tiempo de vida en Rust nos permiten especificar la relaci√≥n entre las referencias y los valores a los que apuntan. Las anotaciones de tiempo de vida se definen usando el s√≠mbolo de comillas (`'`) seguido de un nombre de tiempo de vida.

Por ejemplo, considera el siguiente c√≥digo, en el que usamos anotaciones de tiempo de vida para especificar el tiempo de vida de las referencias devueltas por la funci√≥n `mas_largo`:

<Tabs>
    <TabItem label="C√≥digo" icon="seti:rust">
        ```rust
        fn mas_largo<'a>(s1: &'a String, s2: &'a String) -> &'a String {
            if s1.len() > s2.len() {
                s1
            } else {
                s2
            }
        }

        fn main() {
            let s1 = String::from("Lenguaje");
            let s2 = String::from("Rust");

            let c = mas_largo(&s1, &s2);

            println!("Palabra 1: {}", s1);
            println!("Palabra 2: {}", s2);
            println!("La palabra m√°s larga es: {}", c);
        }
        ```
    </TabItem>
    <TabItem label="Salida" icon="seti:powershell">
        ```bash
        La palabra m√°s larga es: Lenguaje
        ```
    </TabItem>
</Tabs> 

### üõ† Explicaci√≥n de la soluci√≥n

¬øQu√© significa `'a` en `fn mas_largo<'a>(...) -> &'a String`?

- `'a` es un tiempo de vida gen√©rico que especifica que las referencias `s1` y `s2` tienen el mismo tiempo de vida.
- Las referencias `s1` y `s2` deben vivir al menos tanto tiempo como la referencia devuelta por la funci√≥n `mas_largo`.
- As√≠, Rust puede garantizar que la referencia devuelta sigue siendo v√°lida cuando se usa en `main`.

Al especificar el tiempo de vida `'a`, estamos indicando a Rust que las referencias `s1` y `s2` tienen el mismo tiempo de vida que la referencia devuelta por la funci√≥n `mas_largo`. Esto permite a Rust verificar que las referencias siguen siendo v√°lidas cuando se usan en `main`.

## Conclusi√≥n

En resumen, los tiempos de vida en Rust nos permiten gestionar la duraci√≥n de las referencias en nuestro c√≥digo. Al usar anotaciones de tiempo de vida, podemos especificar la relaci√≥n entre las referencias y los valores a los que apuntan, evitando problemas de seguridad y garantizando que las referencias sean v√°lidas en tiempo de ejecuci√≥n.








