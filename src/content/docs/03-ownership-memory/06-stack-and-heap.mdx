---
title: Stack y Heap
description: Aprende sobre la diferencia entre la pila (stack) y el montón (heap) en Rust y cómo se gestionan los datos en cada uno.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

En Rust, la pila (stack) y el montón (heap) son dos áreas de memoria que se utilizan para almacenar datos durante la ejecución de un programa. Cada una de estas áreas tiene sus propias características y se utiliza para diferentes propósitos. En este artículo, aprenderemos sobre la diferencia entre la pila y el montón en Rust y cómo se gestionan los datos en cada una.

## Pila (Stack)

La pila es una estructura de datos en la que se almacenan los valores de las variables y las referencias a las funciones durante la ejecución de un programa. La pila es una estructura de datos de tamaño fijo y de acceso rápido, lo que la hace ideal para almacenar datos de tamaño conocido y que se pueden acceder de forma eficiente.

En Rust, las variables que se almacenan en la pila tienen un tamaño conocido en tiempo de compilación y se eliminan automáticamente cuando salen de su ámbito de visibilidad. Esto se conoce como desapilado (popping) y se realiza de forma automática por el compilador de Rust.

Por ejemplo, considera el siguiente código:

<Tabs>
    <TabItem label="Código" icon="seti:rust">
        ```rust
        fn main() {
            let x = 5;
            let y = 10;

            let z = sumar(x, y);

            println!("La suma es: {}", z);
        }

        fn sumar(a: i32, b: i32) -> i32 {
            a + b
        }
        ```
    </TabItem>
    <TabItem label="Salida" icon="seti:powershell">
        ```bash
        La suma es: 15
        ```
    </TabItem>
</Tabs>

En este ejemplo, las variables `x`, `y` y `z` se almacenan en la pila. Cuando la función `sumar` termina de ejecutarse, las variables locales `a` y `b` se eliminan automáticamente de la pila. Esto se debe a que las variables locales tienen un tiempo de vida limitado y se eliminan cuando salen de su ámbito de visibilidad.

## Montón (Heap)

El montón es una estructura de datos en la que se almacenan los valores de las variables que tienen un tamaño desconocido en tiempo de compilación o que necesitan persistir más allá de su ámbito de visibilidad. El montón es una estructura de datos de tamaño dinámico y de acceso más lento que la pila, ya que requiere la gestión manual de la memoria. 

En Rust, los valores que se almacenan en el montón se gestionan mediante punteros

<Tabs>
    <TabItem label="Código" icon="seti:rust">
        ```rust
        fn main() {
            let mensaje = String::from("Hola, Rust!");

            let propiedad = mensaje;

            println!("El mensaje es: {}", propiedad);
        }
        ```
    </TabItem>
    <TabItem label="Salida" icon="seti:powershell">
        ```bash
        El mensaje es: Hola, Rust!
        ```
    </TabItem>
</Tabs>

En este ejemplo, la variable `mensaje` se almacena en el montón y se le asigna a la variable `propiedad`. Cuando se asigna la variable `mensaje` a la variable `propiedad`, se copia el puntero al valor almacenado en el montón, pero no se copia el valor en sí. Esto se conoce como "transferencia de propiedad" en Rust y garantiza que solo haya un propietario del valor en el montón en un momento dado.


## Conclusión

En resumen, la pila y el montón son dos áreas de memoria que se utilizan para almacenar datos durante la ejecución de un programa en Rust. La pila se utiliza para almacenar valores de tamaño conocido y de acceso rápido, mientras que el montón se utiliza para almacenar valores de tamaño desconocido y de acceso más lento. La gestión de la memoria en la pila es automática y se realiza mediante el desapilado, mientras que la gestión de la memoria en el montón es manual y se realiza mediante la transferencia de propiedad. Al comprender la diferencia entre la pila y el montón, puedes escribir programas más eficientes y seguros en Rust.

:::note
En Rust, la gestión de la memoria se realiza mediante el sistema de propietarios (ownership) y el sistema de préstamos (borrowing). Estos sistemas garantizan que no haya fugas de memoria ni errores de acceso a la memoria durante la ejecución de un programa en Rust.
:::




